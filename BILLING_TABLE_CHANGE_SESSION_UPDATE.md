# تحديث منطق تغيير الطاولة في صفحة الفواتير

## المشكلة الأصلية
عند تغيير الطاولة في صفحة الفواتير، كانت الجلسات المرتبطة بالفاتورة لا تتحدث لتشير إلى الطاولة الجديدة، مما يسبب عدم تطابق في البيانات.

## التحسين المطلوب
تطبيق نفس المنطق المستخدم في `sessionController.js` لضمان الترتيب الصحيح والتعامل مع الحالات المختلفة.

## الحل المحسن

### 1. تحديث دالة `updateBill` في `billingController.js`

تم إعادة كتابة منطق تغيير الطاولة ليتبع نفس الترتيب المطبق في `changeSessionTable`:

#### Case 1: الطاولة الجديدة تحتوي على فاتورة غير مدفوعة (دمج الفواتير)

**الترتيب الصحيح:**
1. **إضافة الطلبات والجلسات إلى الفاتورة الموجودة**
2. **حفظ الفاتورة المدمجة وإعادة حساب المجاميع**
3. **حذف الفاتورة القديمة (التي أصبحت فارغة)**

```javascript
// STEP 1: إضافة الجلسات إلى الفاتورة الجديدة
if (oldBillSessions.length > 0) {
    existingBillInNewTable.sessions.push(...oldBillSessions);
    
    // تحديث مرجع الفاتورة والطاولة في الجلسات
    await Session.updateMany(
        { _id: { $in: oldBillSessions } },
        { $set: { bill: existingBillInNewTable._id, table: newTableId } }
    );
    Logger.info(`✅ STEP 1b: تم إضافة ${oldBillSessions.length} جلسة إلى الفاتورة ${existingBillInNewTable.billNumber} والطاولة ${newTableId}`);
}

// STEP 2: حفظ الفاتورة المدمجة وإعادة حساب المجاميع
await existingBillInNewTable.calculateSubtotal();
await existingBillInNewTable.save();

// STEP 3: حذف الفاتورة القديمة
const { deleteFromBothDatabases } = await import('../utils/deleteHelper.js');
await deleteFromBothDatabases(bill, 'bills', `bill ${oldBillNumber}`);
```

#### Case 2: الطاولة الجديدة فارغة (تغيير الطاولة فقط)

```javascript
// تحديث طاولة الفاتورة
bill.table = newTableId;

// تحديث جميع الجلسات المرتبطة بهذه الفاتورة لتشير إلى الطاولة الجديدة
if (bill.sessions && bill.sessions.length > 0) {
    await Session.updateMany(
        { _id: { $in: bill.sessions } },
        { $set: { table: newTableId } }
    );
    Logger.info(`✅ تم تحديث ${bill.sessions.length} جلسة للطاولة الجديدة`);
}
```

## التحسينات المطبقة

### 1. ترتيب العمليات الصحيح
- تطبيق نفس الترتيب المستخدم في `sessionController.js`
- ضمان عدم فقدان البيانات أثناء العمليات
- معالجة الحالات الاستثنائية بشكل صحيح

### 2. دعم حالتين رئيسيتين
- **Case 1**: دمج مع فاتورة موجودة في الطاولة الجديدة
- **Case 2**: تغيير الطاولة فقط (الطاولة الجديدة فارغة)

### 3. تحديث شامل للجلسات
- تحديث مرجع الفاتورة (`bill`) في الجلسات
- تحديث مرجع الطاولة (`table`) في الجلسات
- ضمان تطابق البيانات بين الفواتير والجلسات والطاولات

### 4. معالجة محسنة للأخطاء
- تسجيل مفصل لكل خطوة
- معالجة الأخطاء دون توقف العملية
- رسائل واضحة للمستخدم

### 5. تحديث حالة الطاولات
- تحديث حالة الطاولة القديمة
- تحديث حالة الطاولة الجديدة
- إشعارات Socket.IO للتحديثات الفورية

## سيناريوهات الاستخدام

### السيناريو الأول: تغيير طاولة فاتورة تحتوي على جلسات
1. المستخدم يفتح صفحة الفواتير
2. يختار فاتورة تحتوي على جلسات نشطة
3. يضغط على "تغيير الطاولة"
4. يختار طاولة جديدة
5. النظام يحدث:
   - طاولة الفاتورة
   - طاولة جميع الطلبات المرتبطة
   - طاولة جميع الجلسات المرتبطة

### السيناريو الثاني: دمج فاتورة مع فاتورة موجودة
1. المستخدم يغير طاولة فاتورة إلى طاولة تحتوي على فاتورة أخرى
2. النظام يدمج الفاتورتين
3. يتم نقل جميع الجلسات إلى الفاتورة المدمجة
4. يتم تحديث طاولة الجلسات لتشير إلى الطاولة الجديدة

## الاختبار

تم إنشاء ملف اختبار `test-billing-table-change.html` للتحقق من:
- إنشاء فاتورة تحتوي على جلسات
- تغيير طاولة الفاتورة
- التحقق من تحديث الجلسات
- اختبار شامل للعملية كاملة

## الملفات المعدلة

1. `server/controllers/billingController.js`
   - تحديث دالة `updateBill`
   - إضافة منطق تحديث الجلسات

2. `test-billing-table-change.html`
   - ملف اختبار جديد للتحقق من الوظيفة

## النتيجة

الآن عند تغيير طاولة فاتورة في صفحة الفواتير:
- ✅ تتحدث طاولة الفاتورة
- ✅ تتحدث طاولة جميع الطلبات المرتبطة
- ✅ تتحدث طاولة جميع الجلسات المرتبطة
- ✅ يتم الحفاظ على تطابق البيانات
- ✅ يتم تسجيل العمليات بشكل مفصل