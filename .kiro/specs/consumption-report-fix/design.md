# مستند التصميم

## نظرة عامة

تقرير الاستهلاك الحالي يعتمد على الفواتير لحساب المبيعات، مما يؤدي إلى أرقام غير دقيقة. سنقوم بإعادة تصميم التقرير ليجلب البيانات مباشرة من الطلبات والجلسات، مما يضمن دقة الأرقام.

## البنية المعمارية

### النهج الحالي (المشكلة)
```
Frontend → getBills() → Filter by date → Process bills → Display
```

المشاكل:
- الفواتير قد لا تحتوي على جميع الطلبات
- بعض الفواتير قد يكون لها total = 0 رغم وجود طلبات
- الاعتماد على الفواتير يضيف طبقة غير ضرورية

### النهج الجديد (الحل)
```
Frontend → getOrders() + getSessions() → Filter by date → Process directly → Display
```

المزايا:
- بيانات دقيقة 100%
- أسرع في الأداء
- أبسط في المنطق

## المكونات والواجهات

### 1. Frontend (ConsumptionReport.tsx)

#### التغييرات المطلوبة:

**أ. إزالة الاعتماد على bills:**
```typescript
// قبل:
const filteredBills = bills.filter(...)
const processedData = processBills(filteredBills, filteredSessions)

// بعد:
const filteredOrders = orders.filter(...)
const filteredSessions = sessions.filter(...)
const processedData = processData(filteredOrders, filteredSessions)
```

**ب. دالة جديدة لمعالجة البيانات:**
```typescript
const processData = (orders: Order[], sessions: Session[]) => {
  const itemsBySection: Record<string, ConsumptionItem[]> = {};
  
  // معالجة الطلبات
  orders.forEach(order => {
    order.items.forEach(item => {
      // جمع الأصناف المتشابهة
      // حساب الإجمالي
    });
  });
  
  // معالجة الجلسات
  sessions.forEach(session => {
    // حساب الساعات والتكلفة
  });
  
  return itemsBySection;
}
```

### 2. Backend API

#### نقاط النهاية الموجودة:
- `GET /api/orders` - جلب جميع الطلبات
- `GET /api/sessions` - جلب جميع الجلسات

#### التحسينات المطلوبة:
- إضافة فلترة بالتاريخ في الاستعلام
- تحسين الأداء باستخدام projection
- إضافة pagination إذا لزم الأمر

## نماذج البيانات

### Order (موجود)
```typescript
{
  _id: ObjectId,
  orderNumber: string,
  items: [{
    name: string,
    price: number,
    quantity: number,
    menuItem: ObjectId
  }],
  status: string,
  total: number,
  createdAt: Date
}
```

### Session (موجود)
```typescript
{
  _id: ObjectId,
  deviceType: 'playstation' | 'computer',
  deviceName: string,
  deviceNumber: number,
  status: 'active' | 'completed',
  startTime: Date,
  endTime: Date,
  totalCost: number,
  finalCost: number
}
```

### ConsumptionItem (Frontend)
```typescript
{
  id: string,
  name: string,
  price: number,
  quantity: number,
  total: number,
  category: string
}
```

## خصائص الصحة

*الخاصية هي سلوك يجب أن يكون صحيحاً عبر جميع التنفيذات الصالحة للنظام - في الأساس، بيان رسمي حول ما يجب أن يفعله النظام. تعمل الخصائص كجسر بين المواصفات المقروءة للإنسان وضمانات الصحة القابلة للتحقق آلياً.*


### تحليل معايير القبول

1.1 WHEN يتم عرض تقرير الاستهلاك THEN النظام SHALL يحسب إجمالي المبيعات من جميع الطلبات المكتملة في الفترة المحددة
Thoughts: هذا يتحدث عن قاعدة يجب أن تطبق على جميع الطلبات في أي فترة زمنية. يمكننا إنشاء طلبات عشوائية وفترة زمنية عشوائية، ثم التحقق من أن الإجمالي يساوي مجموع جميع الطلبات في تلك الفترة.
Testable: yes - property

1.2 WHEN يتم عرض تقرير الاستهلاك THEN النظام SHALL يحسب إجمالي المبيعات من جميع جلسات البلايستيشن المكتملة في الفترة المحددة
Thoughts: هذا يتحدث عن قاعدة يجب أن تطبق على جميع الجلسات في أي فترة زمنية. يمكننا إنشاء جلسات عشوائية وفترة زمنية عشوائية، ثم التحقق من أن الإجمالي يساوي مجموع جميع الجلسات في تلك الفترة.
Testable: yes - property

1.3 WHEN يتم حساب المبيعات THEN النظام SHALL يجمع كميات الأصناف المتشابهة من جميع الطلبات
Thoughts: هذا يتحدث عن قاعدة يجب أن تطبق على جميع الأصناف. إذا كان لدينا نفس الصنف في طلبات مختلفة، يجب أن يتم جمع الكميات. يمكننا إنشاء طلبات عشوائية تحتوي على أصناف متكررة والتحقق من أن الكميات مجموعة بشكل صحيح.
Testable: yes - property

1.4 WHEN يتم حساب المبيعات THEN النظام SHALL يحسب الإجمالي الصحيح لكل صنف (الكمية × السعر)
Thoughts: هذا يتحدث عن قاعدة حسابية يجب أن تطبق على جميع الأصناف. لأي صنف، الإجمالي يجب أن يساوي الكمية × السعر. هذا ثابت رياضي.
Testable: yes - property

1.5 WHEN يتم فلترة البيانات بالتاريخ THEN النظام SHALL يستخدم تاريخ إنشاء الطلب (createdAt) للطلبات وتاريخ انتهاء الجلسة (endTime) للجلسات
Thoughts: هذا يتحدث عن قاعدة الفلترة. يمكننا إنشاء طلبات وجلسات بتواريخ مختلفة، ثم فلترة بفترة زمنية معينة، والتحقق من أن النتائج تحتوي فقط على العناصر في تلك الفترة.
Testable: yes - property

2.1 WHEN يتم عرض صنف في التقرير THEN النظام SHALL يعرض اسم الصنف والكمية الإجمالية والسعر والإجمالي
Thoughts: هذا يتحدث عن محتوى العرض. لأي صنف معروض، يجب أن يحتوي على هذه الحقول. يمكننا إنشاء أصناف عشوائية والتحقق من أن كل صنف يحتوي على هذه الحقول.
Testable: yes - property

2.2 WHEN يتم عرض جلسات البلايستيشن THEN النظام SHALL يعرض عدد الساعات الإجمالية والتكلفة الإجمالية لكل جهاز
Thoughts: هذا يتحدث عن محتوى العرض للجلسات. لأي جهاز معروض، يجب أن يحتوي على الساعات والتكلفة. يمكننا إنشاء جلسات عشوائية والتحقق من أن كل جهاز يحتوي على هذه الحقول.
Testable: yes - property

2.3 WHEN يتم حساب ساعات البلايستيشن THEN النظام SHALL يحسب الفرق بين startTime و endTime بالساعات
Thoughts: هذا يتحدث عن قاعدة حسابية. لأي جلسة، الساعات يجب أن تساوي (endTime - startTime) / (1000 * 60 * 60). هذا ثابت رياضي.
Testable: yes - property

2.4 WHEN يتم عرض الأصناف THEN النظام SHALL يرتبها حسب الإجمالي من الأعلى إلى الأقل
Thoughts: هذا يتحدث عن قاعدة الترتيب. لأي قائمة من الأصناف، يجب أن تكون مرتبة بحيث كل عنصر >= العنصر التالي. يمكننا إنشاء أصناف عشوائية والتحقق من أن القائمة مرتبة.
Testable: yes - property

4.1 WHEN يتم عرض التقرير THEN النظام SHALL يعرض إجمالي المبيعات الكلي
Thoughts: هذا يتحدث عن محتوى العرض. يجب أن يحتوي التقرير على إجمالي المبيعات. يمكننا إنشاء بيانات عشوائية والتحقق من أن الإجمالي موجود ويساوي مجموع جميع العناصر.
Testable: yes - property

4.2 WHEN يتم عرض التقرير THEN النظام SHALL يعرض عدد الأصناف المباعة
Thoughts: هذا يتحدث عن محتوى العرض. يجب أن يحتوي التقرير على عدد الأصناف. يمكننا إنشاء بيانات عشوائية والتحقق من أن العدد يساوي عدد الأصناف الفريدة.
Testable: yes - property

4.3 WHEN يتم عرض التقرير THEN النظام SHALL يعرض عدد الفئات
Thoughts: هذا يتحدث عن محتوى العرض. يجب أن يحتوي التقرير على عدد الفئات. يمكننا إنشاء بيانات عشوائية والتحقق من أن العدد يساوي عدد الفئات الفريدة.
Testable: yes - property

4.4 WHEN يتم عرض التقرير THEN النظام SHALL يعرض الإجمالي لكل فئة (قسم من القائمة)
Thoughts: هذا يتحدث عن محتوى العرض. لكل فئة، يجب أن يكون هناك إجمالي. يمكننا إنشاء بيانات عشوائية والتحقق من أن كل فئة لها إجمالي يساوي مجموع أصنافها.
Testable: yes - property

### خصائص الصحة

**الخاصية 1: دقة حساب إجمالي الطلبات**
*لأي* مجموعة من الطلبات وفترة زمنية، يجب أن يساوي إجمالي المبيعات المحسوب مجموع (السعر × الكمية) لجميع الأصناف في الطلبات التي تقع ضمن الفترة الزمنية
**Validates: Requirements 1.1, 1.4**

**الخاصية 2: دقة حساب إجمالي الجلسات**
*لأي* مجموعة من جلسات البلايستيشن المكتملة وفترة زمنية، يجب أن يساوي إجمالي المبيعات المحسوب مجموع totalCost لجميع الجلسات التي تقع ضمن الفترة الزمنية
**Validates: Requirements 1.2**

**الخاصية 3: جمع الأصناف المتشابهة**
*لأي* مجموعة من الطلبات تحتوي على نفس الصنف، يجب أن تكون الكمية الإجمالية للصنف في التقرير مساوية لمجموع كميات هذا الصنف في جميع الطلبات
**Validates: Requirements 1.3**

**الخاصية 4: صحة حساب الإجمالي لكل صنف**
*لأي* صنف في التقرير، يجب أن يساوي الإجمالي (الكمية × السعر)
**Validates: Requirements 1.4**

**الخاصية 5: دقة فلترة التاريخ**
*لأي* فترة زمنية محددة، يجب أن تحتوي النتائج فقط على الطلبات التي createdAt ضمن الفترة والجلسات التي endTime ضمن الفترة
**Validates: Requirements 1.5**

**الخاصية 6: اكتمال بيانات الصنف**
*لأي* صنف معروض في التقرير، يجب أن يحتوي على الحقول: name, quantity, price, total
**Validates: Requirements 2.1**

**الخاصية 7: اكتمال بيانات الجلسة**
*لأي* جهاز بلايستيشن معروض في التقرير، يجب أن يحتوي على الحقول: name, quantity (ساعات), total (تكلفة)
**Validates: Requirements 2.2**

**الخاصية 8: دقة حساب ساعات البلايستيشن**
*لأي* جلسة بلايستيشن مكتملة، يجب أن تساوي الساعات المحسوبة (endTime - startTime) / (1000 * 60 * 60)
**Validates: Requirements 2.3**

**الخاصية 9: ترتيب الأصناف**
*لأي* قائمة من الأصناف في التقرير، يجب أن تكون مرتبة بحيث total[i] >= total[i+1] لجميع i
**Validates: Requirements 2.4**

**الخاصية 10: دقة الإجمالي الكلي**
*لأي* تقرير، يجب أن يساوي إجمالي المبيعات الكلي مجموع total لجميع الأصناف (بما في ذلك البلايستيشن)
**Validates: Requirements 4.1**

**الخاصية 11: دقة عدد الأصناف**
*لأي* تقرير، يجب أن يساوي عدد الأصناف المباعة عدد العناصر الفريدة في القائمة
**Validates: Requirements 4.2**

**الخاصية 12: دقة عدد الفئات**
*لأي* تقرير، يجب أن يساوي عدد الفئات عدد الأقسام الفريدة التي تحتوي على أصناف
**Validates: Requirements 4.3**

**الخاصية 13: دقة إجمالي كل فئة**
*لأي* فئة في التقرير، يجب أن يساوي إجمالي الفئة مجموع total لجميع الأصناف في تلك الفئة
**Validates: Requirements 4.4**

## معالجة الأخطاء

### سيناريوهات الأخطاء المحتملة:

1. **لا توجد بيانات في الفترة المحددة**
   - عرض رسالة "لا توجد بيانات متاحة للفترة المحددة"
   - عرض إحصائيات بقيمة صفر

2. **خطأ في جلب البيانات من API**
   - عرض رسالة خطأ واضحة
   - توفير زر "إعادة المحاولة"
   - تسجيل الخطأ في console

3. **بيانات غير صحيحة (null/undefined)**
   - استخدام قيم افتراضية (0 للأرقام، '' للنصوص)
   - تسجيل تحذير في console

4. **جلسة بدون endTime**
   - تجاهل الجلسة (لأنها غير مكتملة)
   - عدم إضافتها للتقرير

## استراتيجية الاختبار

### اختبارات الوحدة (Unit Tests)

1. **اختبار دالة processData:**
   - اختبار مع طلبات فارغة
   - اختبار مع جلسات فارغة
   - اختبار مع بيانات صحيحة
   - اختبار جمع الأصناف المتشابهة

2. **اختبار دالة filterByDate:**
   - اختبار فلترة الطلبات بالتاريخ
   - اختبار فلترة الجلسات بالتاريخ
   - اختبار حالات الحدود (بداية/نهاية اليوم)

3. **اختبار دالة calculateHours:**
   - اختبار حساب الساعات من startTime و endTime
   - اختبار مع قيم null/undefined

### اختبارات الخصائص (Property-Based Tests)

سنستخدم مكتبة **fast-check** لـ TypeScript لإجراء اختبارات الخصائص.

**التكوين:**
- عدد التكرارات: 100 لكل اختبار
- استخدام generators عشوائية للبيانات
- التحقق من الخصائص المذكورة أعلاه

**مثال على اختبار خاصية:**
```typescript
import fc from 'fast-check';

// Feature: consumption-report-fix, Property 1: دقة حساب إجمالي الطلبات
test('Property 1: Total sales equals sum of all items', () => {
  fc.assert(
    fc.property(
      fc.array(orderGenerator()),
      fc.date(),
      fc.date(),
      (orders, startDate, endDate) => {
        const result = processData(orders, []);
        const expectedTotal = orders
          .filter(o => isInRange(o.createdAt, startDate, endDate))
          .reduce((sum, o) => sum + o.total, 0);
        return result.totalSales === expectedTotal;
      }
    ),
    { numRuns: 100 }
  );
});
```

### اختبارات التكامل

1. **اختبار التكامل مع API:**
   - اختبار جلب الطلبات من API
   - اختبار جلب الجلسات من API
   - اختبار معالجة البيانات المجلوبة

2. **اختبار UI:**
   - اختبار تغيير نطاق التاريخ
   - اختبار التبديل بين التبويبات
   - اختبار تصدير PDF

## الأداء

### التحسينات المطلوبة:

1. **استخدام useMemo للبيانات المحسوبة:**
   ```typescript
   const allItems = useMemo(() => 
     Object.values(consumptionData).flat(), 
     [consumptionData]
   );
   ```

2. **استخدام useCallback للدوال:**
   ```typescript
   const processData = useCallback((orders, sessions) => {
     // ...
   }, [menuItems, menuSections]);
   ```

3. **تحسين استعلامات API:**
   - استخدام projection لجلب الحقول المطلوبة فقط
   - إضافة indexes على حقول التاريخ

4. **Lazy loading للبيانات:**
   - جلب البيانات فقط عند الحاجة
   - استخدام pagination إذا كانت البيانات كبيرة

## الأمان

- التحقق من صلاحيات المستخدم قبل عرض التقرير
- تشفير البيانات الحساسة
- منع SQL injection في استعلامات قاعدة البيانات
- استخدام HTTPS لجميع طلبات API

## التوافق

- دعم جميع المتصفحات الحديثة (Chrome, Firefox, Safari, Edge)
- دعم الأجهزة المحمولة (responsive design)
- دعم اللغة العربية (RTL)
- دعم تنسيقات التاريخ العربية
